var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BABYLON;
(function (BABYLON) {
    BABYLON.Effect.ShadersStore["BadTVFragmentShader"] = "precision highp float;\nuniform sampler2D tDiffuse;\nuniform float time;\nuniform float distortion;\nuniform float distortion2;\nuniform float speed;\nuniform float rollSpeed;\nvarying vec2 vUV;\n\t\t\n\n\n\tvec3 mod289(vec3 x) {\n\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec2 mod289(vec2 x) {\n\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t}\n\n\tvec3 permute(vec3 x) {\n\t\treturn mod289(((x*34.0)+1.0)*x);\n\t}\n\n\tfloat snoise(vec2 v)\n\t{\n\t\tconst vec4 C = vec4(0.211324865405187,  \n\t\t                      0.366025403784439,  \n\t\t                     -0.577350269189626, \n\t\t                      0.024390243902439); \n\t\t  vec2 i  = floor(v + dot(v, C.yy) );\n\t\t  vec2 x0 = v -   i + dot(i, C.xx);\n\n\t\t  vec2 i1;\n\t\t  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t  vec4 x12 = x0.xyxy + C.xxzz;\n\t\t  x12.xy -= i1;\n\n\t\t  i = mod289(i); \n\t\t  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n\t\t  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t  m = m*m ;\n\t\t  m = m*m ;\n\n\t\t  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t  vec3 h = abs(x) - 0.5;\n\t\t  vec3 ox = floor(x + 0.5);\n\t\t  vec3 a0 = x - ox;\n\n\t\t  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\t\t  vec3 g;\n\t\t  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\t\t  return 130.0 * dot(m, g);\n\t\t}\n\n\n\t\tvoid main() {\n\n\t\t\tvec2 p = vUV;\n\t\t\tfloat ty = time*speed;\n\t\t\tfloat yt = p.y - ty;\n\t\t\tfloat offset = snoise(vec2(yt*3.0,0.0))*0.2;\n\t\t\toffset = offset*distortion * offset*distortion * offset;\n\t\t\toffset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;\n\t\t\tgl_FragColor = texture2D(tDiffuse,  vec2(fract(p.x + offset),fract(p.y-time*rollSpeed) ));\n\n\t\t}";
    var BadTVPostProcess = (function (_super) {
        __extends(BadTVPostProcess, _super);
        function BadTVPostProcess(name, options, _postProcessTexture, camera, samplingMode, engine, reusable) {
            var _this = this;
            if (reusable === void 0) { reusable = true; }
            _super.call(this, name, "BadTV", ["time", "distortion", "distortion2", "speed", "rollSpeed"], ["tDiffuse"], 1, camera, samplingMode, engine, reusable);
            this.time = 0.0;
            this.distortion = 3.0;
            this.distortion2 = 5.0;
            this.speed = 0.2;
            this.rollSpeed = 0.4;
            this.postProcessTexture = _postProcessTexture;
            this.onApplyObservable.add(function (effect) {
                effect.setTextureFromPostProcess("tDiffuse", _this.postProcessTexture);
                effect.setFloat("time", _this.time);
                effect.setFloat("distortion", _this.distortion);
                effect.setFloat("distortion2", _this.distortion2);
                effect.setFloat("speed", _this.speed);
                effect.setFloat("rollSpeed", _this.rollSpeed);
            });
        }
        return BadTVPostProcess;
    }(BABYLON.PostProcess));
    BABYLON.BadTVPostProcess = BadTVPostProcess;
})(BABYLON || (BABYLON = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BABYLON;
(function (BABYLON) {
    BABYLON.Effect.ShadersStore["filmFragmentShader"] = "precision highp float;\n// control parameter\nuniform float time;\nuniform bool grayscale;\n// noise effect intensity value (0 = no effect, 1 = full effect)\nuniform float nIntensity;\n// scanlines effect intensity value (0 = no effect, 1 = full effect)\nuniform float sIntensity;\n// scanlines effect count value (0 = no effect, 4096 = full effect)\nuniform float sCount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUV;\nvoid main() {\n\t// sample the source\n\tvec4 cTextureScreen = texture2D( tDiffuse, vUV );\n\t// make some noise\n\tfloat x = vUV.x * vUV.y * time *  1000.0;\n\tx = mod( x, 13.0 ) * mod( x, 123.0 );\n\tfloat dx = mod( x, 0.01 );\n\t// add noise\n\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\n\t// get us a sine and cosine\n\tvec2 sc = vec2( sin( vUV.y * sCount ), cos( vUV.y * sCount ) );\n\t// add scanlines\n\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\n\t// interpolate between source and result by intensity\n\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\n\t// convert to grayscale if desired\n\tif( grayscale ) {\n\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n\t}\n\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\n}";
    var FilmPostProcess = (function (_super) {
        __extends(FilmPostProcess, _super);
        function FilmPostProcess(name, options, _postProcessTexture, camera, samplingMode, engine, reusable) {
            var _this = this;
            if (reusable === void 0) { reusable = true; }
            _super.call(this, name, "film", ["time", "nIntensity", "sIntensity", "sCount", "grayscale"], ["tDiffuse"], 1, camera, samplingMode, engine, reusable);
            this.time = 0;
            this.nIntensity = 0.5;
            this.sIntensity = 0.05;
            this.sCount = 4096.0;
            this.grayscale = true;
            this.postProcessTexture = _postProcessTexture;
            this.onApplyObservable.add(function (effect) {
                effect.setTextureFromPostProcess("tDiffuse", _this.postProcessTexture);
                effect.setFloat("time", _this.time);
                effect.setFloat("nIntensity", _this.nIntensity);
                effect.setFloat("sIntensity", _this.sIntensity);
                effect.setFloat("sCount", _this.sCount);
                effect.setBool("grayscale", _this.grayscale);
            });
        }
        return FilmPostProcess;
    }(BABYLON.PostProcess));
    BABYLON.FilmPostProcess = FilmPostProcess;
})(BABYLON || (BABYLON = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BABYLON;
(function (BABYLON) {
    BABYLON.Effect.ShadersStore["RGBShiftFragmentShader"] = "precision highp float;\n\nuniform sampler2D textureSampler;\n//uniform sampler2D tDiffuse = 0;\nuniform float amount;\nuniform float angle;\n\nvarying vec2 vUV;\n\nvoid main() {\n//amount = 0.005;\n//angle = 0.0;\n\nvec2 offset = amount * vec2( cos(angle), sin(angle));\nvec4 cr = texture2D(textureSampler, vUV + offset);\nvec4 cga = texture2D(textureSampler, vUV);\nvec4 cb = texture2D(textureSampler, vUV - offset);\ngl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n}\n";
    var RGBShiftPostProcess = (function (_super) {
        __extends(RGBShiftPostProcess, _super);
        function RGBShiftPostProcess(name, options, camera, samplingMode, engine, reusable) {
            var _this = this;
            if (reusable === void 0) { reusable = true; }
            _super.call(this, name, "RGBShift", ["amount", "angle"], null, 1, camera, samplingMode, engine, reusable);
            this.amount = 0.015;
            this.angle = 90.05;
            this.onApplyObservable.add(function (effect) {
                effect.setFloat("amount", _this.amount);
                effect.setFloat("angle", _this.angle);
            });
        }
        return RGBShiftPostProcess;
    }(BABYLON.PostProcess));
    BABYLON.RGBShiftPostProcess = RGBShiftPostProcess;
})(BABYLON || (BABYLON = {}));
